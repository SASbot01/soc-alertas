package com.blackwolf.backend.service;

import com.blackwolf.backend.dto.PentestDTOs.*;
import com.blackwolf.backend.model.PenetrationTest;
import com.blackwolf.backend.model.PentestFinding;
import com.blackwolf.backend.repository.PenetrationTestRepository;
import com.blackwolf.backend.repository.PentestFindingRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
public class PentestService {

    private static final List<String> PENTEST_LIFECYCLE = List.of(
            "PLANNING", "RECONNAISSANCE", "EXPLOITATION", "POST_EXPLOITATION", "REPORTING", "DELIVERED"
    );

    @Autowired
    private PenetrationTestRepository pentestRepository;

    @Autowired
    private PentestFindingRepository findingRepository;

    @Autowired
    private ActivityLogService activityLogService;

    public List<PenetrationTest> listByCompany(String companyId) {
        return pentestRepository.findByCompanyId(companyId);
    }

    public PentestDetailResponse getDetail(String pentestId, String companyId) {
        PenetrationTest pentest = pentestRepository.findById(pentestId)
                .orElseThrow(() -> new RuntimeException("Pentest not found"));
        if (!pentest.getCompanyId().equals(companyId)) {
            throw new RuntimeException("Access denied");
        }

        List<PentestFinding> findings = findingRepository.findByPentestId(pentestId);

        PentestDetailResponse response = new PentestDetailResponse();
        response.setId(pentest.getId());
        response.setCompanyId(pentest.getCompanyId());
        response.setTitle(pentest.getTitle());
        response.setTestType(pentest.getTestType());
        response.setStatus(pentest.getStatus());
        response.setScope(pentest.getScope());
        response.setRulesOfEngagement(pentest.getRulesOfEngagement());
        response.setTargetSystems(pentest.getTargetSystems());
        response.setTester(pentest.getTester());
        response.setStartDate(pentest.getStartDate());
        response.setEndDate(pentest.getEndDate());
        response.setExecutiveSummary(pentest.getExecutiveSummary());
        response.setCreatedAt(pentest.getCreatedAt());
        response.setUpdatedAt(pentest.getUpdatedAt());
        response.setFindings(findings.stream().map(this::toFindingSummary).collect(Collectors.toList()));

        return response;
    }

    @Transactional
    public PenetrationTest create(String companyId, CreatePentestRequest request, String performedBy) {
        PenetrationTest pentest = new PenetrationTest();
        pentest.setId(UUID.randomUUID().toString());
        pentest.setCompanyId(companyId);
        pentest.setTitle(request.getTitle());
        pentest.setTestType(request.getTestType());
        pentest.setStatus("PLANNING");
        pentest.setScope(request.getScope());
        pentest.setRulesOfEngagement(request.getRulesOfEngagement());
        pentest.setTargetSystems(request.getTargetSystems());
        pentest.setTester(request.getTester());
        pentest.setStartDate(request.getStartDate());
        pentest.setEndDate(request.getEndDate());
        pentest.setCreatedAt(LocalDateTime.now());
        pentest.setUpdatedAt(LocalDateTime.now());

        pentest = pentestRepository.save(pentest);

        activityLogService.log(companyId, "PENTEST", pentest.getId(), "CREATED", performedBy,
                "Pentest created: " + pentest.getTitle());

        return pentest;
    }

    @Transactional
    public PenetrationTest updateStatus(String pentestId, String companyId, UpdatePentestStatusRequest request, String performedBy) {
        PenetrationTest pentest = pentestRepository.findById(pentestId)
                .orElseThrow(() -> new RuntimeException("Pentest not found"));
        if (!pentest.getCompanyId().equals(companyId)) {
            throw new RuntimeException("Access denied");
        }

        String newStatus = request.getStatus();
        validateStatusTransition(pentest.getStatus(), newStatus);

        String oldStatus = pentest.getStatus();
        pentest.setStatus(newStatus);
        if (request.getExecutiveSummary() != null) {
            pentest.setExecutiveSummary(request.getExecutiveSummary());
        }
        pentest.setUpdatedAt(LocalDateTime.now());

        pentest = pentestRepository.save(pentest);

        activityLogService.log(companyId, "PENTEST", pentest.getId(), "STATUS_CHANGED", performedBy,
                "Status changed from " + oldStatus + " to " + newStatus);

        return pentest;
    }

    @Transactional
    public PentestFinding addFinding(String pentestId, String companyId, CreatePentestFindingRequest request, String performedBy) {
        PenetrationTest pentest = pentestRepository.findById(pentestId)
                .orElseThrow(() -> new RuntimeException("Pentest not found"));
        if (!pentest.getCompanyId().equals(companyId)) {
            throw new RuntimeException("Access denied");
        }

        PentestFinding finding = new PentestFinding();
        finding.setId(UUID.randomUUID().toString());
        finding.setPentestId(pentestId);
        finding.setTitle(request.getTitle());
        finding.setDescription(request.getDescription());
        finding.setSeverity(request.getSeverity());
        finding.setCvssScore(request.getCvssScore());
        finding.setAffectedComponent(request.getAffectedComponent());
        finding.setProofOfConcept(request.getProofOfConcept());
        finding.setEvidence(request.getEvidence());
        finding.setRecommendation(request.getRecommendation());
        finding.setStatus("OPEN");
        finding.setCreatedAt(LocalDateTime.now());

        finding = findingRepository.save(finding);

        activityLogService.log(companyId, "PENTEST", pentestId, "FINDING_ADDED", performedBy,
                "Finding added: " + finding.getTitle() + " [" + finding.getSeverity() + "]");

        return finding;
    }

    private void validateStatusTransition(String current, String next) {
        int currentIdx = PENTEST_LIFECYCLE.indexOf(current);
        int nextIdx = PENTEST_LIFECYCLE.indexOf(next);
        if (currentIdx == -1 || nextIdx == -1 || nextIdx != currentIdx + 1) {
            throw new RuntimeException("Cannot transition from " + current + " to " + next);
        }
    }

    private PentestFindingSummary toFindingSummary(PentestFinding f) {
        PentestFindingSummary s = new PentestFindingSummary();
        s.setId(f.getId());
        s.setTitle(f.getTitle());
        s.setSeverity(f.getSeverity());
        s.setCvssScore(f.getCvssScore());
        s.setAffectedComponent(f.getAffectedComponent());
        s.setStatus(f.getStatus());
        s.setCreatedAt(f.getCreatedAt());
        return s;
    }
}
