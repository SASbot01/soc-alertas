package com.blackwolf.backend.service;

import com.blackwolf.backend.dto.VulnerabilityDTOs.*;
import com.blackwolf.backend.model.Vulnerability;
import com.blackwolf.backend.repository.VulnerabilityRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Service
public class VulnerabilityService {

    private static final List<String> VULN_LIFECYCLE = List.of(
            "DETECTED", "CONFIRMED", "IN_REMEDIATION", "FIXED", "VERIFIED"
    );

    @Autowired
    private VulnerabilityRepository vulnerabilityRepository;

    @Autowired
    private ActivityLogService activityLogService;

    public List<Vulnerability> listByCompany(String companyId) {
        return vulnerabilityRepository.findByCompanyId(companyId);
    }

    public VulnerabilityDetailResponse getDetail(String vulnId, String companyId) {
        Vulnerability vuln = vulnerabilityRepository.findById(vulnId)
                .orElseThrow(() -> new RuntimeException("Vulnerability not found"));
        if (!vuln.getCompanyId().equals(companyId)) {
            throw new RuntimeException("Access denied");
        }

        VulnerabilityDetailResponse response = new VulnerabilityDetailResponse();
        response.setId(vuln.getId());
        response.setCompanyId(vuln.getCompanyId());
        response.setTitle(vuln.getTitle());
        response.setDescription(vuln.getDescription());
        response.setCveId(vuln.getCveId());
        response.setRiskLevel(vuln.getRiskLevel());
        response.setCvssScore(vuln.getCvssScore());
        response.setAffectedAsset(vuln.getAffectedAsset());
        response.setStatus(vuln.getStatus());
        response.setRemediationPlan(vuln.getRemediationPlan());
        response.setRemediationDeadline(vuln.getRemediationDeadline());
        response.setVerifiedAt(vuln.getVerifiedAt());
        response.setDetectedAt(vuln.getDetectedAt());
        response.setUpdatedAt(vuln.getUpdatedAt());
        return response;
    }

    @Transactional
    public Vulnerability create(String companyId, CreateVulnerabilityRequest request, String performedBy) {
        Vulnerability vuln = new Vulnerability();
        vuln.setId(UUID.randomUUID().toString());
        vuln.setCompanyId(companyId);
        vuln.setTitle(request.getTitle());
        vuln.setDescription(request.getDescription());
        vuln.setCveId(request.getCveId());
        vuln.setRiskLevel(request.getRiskLevel());
        vuln.setCvssScore(request.getCvssScore());
        vuln.setAffectedAsset(request.getAffectedAsset());
        vuln.setStatus("DETECTED");
        vuln.setRemediationPlan(request.getRemediationPlan());
        vuln.setRemediationDeadline(request.getRemediationDeadline());
        vuln.setDetectedAt(LocalDateTime.now());
        vuln.setUpdatedAt(LocalDateTime.now());

        vuln = vulnerabilityRepository.save(vuln);

        activityLogService.log(companyId, "VULNERABILITY", vuln.getId(), "CREATED", performedBy,
                "Vulnerability detected: " + vuln.getTitle() + " [" + vuln.getRiskLevel() + "]");

        return vuln;
    }

    @Transactional
    public Vulnerability updateStatus(String vulnId, String companyId, UpdateVulnerabilityStatusRequest request, String performedBy) {
        Vulnerability vuln = vulnerabilityRepository.findById(vulnId)
                .orElseThrow(() -> new RuntimeException("Vulnerability not found"));
        if (!vuln.getCompanyId().equals(companyId)) {
            throw new RuntimeException("Access denied");
        }

        String newStatus = request.getStatus();
        validateStatusTransition(vuln.getStatus(), newStatus);

        String oldStatus = vuln.getStatus();
        vuln.setStatus(newStatus);
        if (request.getRemediationPlan() != null) {
            vuln.setRemediationPlan(request.getRemediationPlan());
        }
        if ("VERIFIED".equals(newStatus)) {
            vuln.setVerifiedAt(LocalDateTime.now());
        }
        vuln.setUpdatedAt(LocalDateTime.now());

        vuln = vulnerabilityRepository.save(vuln);

        activityLogService.log(companyId, "VULNERABILITY", vuln.getId(), "STATUS_CHANGED", performedBy,
                "Status changed from " + oldStatus + " to " + newStatus);

        return vuln;
    }

    public VulnerabilityDashboard getDashboard(String companyId) {
        VulnerabilityDashboard dashboard = new VulnerabilityDashboard();
        List<Vulnerability> all = vulnerabilityRepository.findByCompanyId(companyId);

        dashboard.setTotal(all.size());
        dashboard.setDetected(all.stream().filter(v -> "DETECTED".equals(v.getStatus())).count());
        dashboard.setConfirmed(all.stream().filter(v -> "CONFIRMED".equals(v.getStatus())).count());
        dashboard.setInRemediation(all.stream().filter(v -> "IN_REMEDIATION".equals(v.getStatus())).count());
        dashboard.setFixed(all.stream().filter(v -> "FIXED".equals(v.getStatus())).count());
        dashboard.setVerified(all.stream().filter(v -> "VERIFIED".equals(v.getStatus())).count());
        dashboard.setCritical(all.stream().filter(v -> "CRITICAL".equals(v.getRiskLevel())).count());
        dashboard.setHigh(all.stream().filter(v -> "HIGH".equals(v.getRiskLevel())).count());
        dashboard.setMedium(all.stream().filter(v -> "MEDIUM".equals(v.getRiskLevel())).count());
        dashboard.setLow(all.stream().filter(v -> "LOW".equals(v.getRiskLevel())).count());

        return dashboard;
    }

    private void validateStatusTransition(String current, String next) {
        int currentIdx = VULN_LIFECYCLE.indexOf(current);
        int nextIdx = VULN_LIFECYCLE.indexOf(next);
        if (currentIdx == -1 || nextIdx == -1 || nextIdx != currentIdx + 1) {
            throw new RuntimeException("Cannot transition from " + current + " to " + next);
        }
    }
}
